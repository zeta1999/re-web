<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ReWeb__Manual__Ch05_Filters (re-web.ReWeb__Manual__Ch05_Filters)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">re-web</a> &#x00BB; ReWeb__Manual__Ch05_Filters</nav><h1>Module <code>ReWeb__Manual__Ch05_Filters</code></h1><p>Filters are middlewares. They plug into the ReWeb request-response pipeline and do various tasks, as explained in <code>Ch01_Introduction</code>.</p><p>Filters help to keep services clean, by extracting functionality that is not conceptually part of the service. They also help to keep code reusable and composeable.</p><h2 id="creating-a-filter"><a href="#creating-a-filter" class="anchor"></a>Creating a filter</h2><p>This section shows how to create filters. To see how to actually insert filters into your application, go to <a href="index.html#inserting"><span>Inserting a filter in the request-response pipeline</span></a>.</p><p>Here's the simplest possible filter:</p><pre><code class="ml">let noFilter = service =&gt; service;</code></pre><p>In other words, that is the 'identity filter'. Remember that a service is a function that takes a request and returns a promise of a response. So that filter can be written as:</p><pre><code class="ml">let noFilter = service =&gt; request =&gt; service(request);</code></pre><p>However, due to a ReWeb naming convention and also due to Reason's default formatting rules, we normally write filters like this:</p><pre><code class="ml">let noFilter = (next, request) =&gt; next(request);</code></pre><p>Here, <code>next</code> is a reminder that that is the <i>next</i> service in the pipeline after the current filter.</p><h3 id="doing-something-in-a-filter"><a href="#doing-something-in-a-filter" class="anchor"></a>Doing something in a filter</h3><p>Ultimately, a filter returns a promise of a response. You have two main options when you need to return something:</p><ul><li>Return <code>next(request)</code> or <code>next(some updated request)</code> on the 'happy path'</li><li>Return a response with an HTTP status that indicates an error on the sad path</li></ul><p>Here's an example of a filter that validates that there's a <code>SESSION</code> cookie in the request and returns a 401 Unauthorized response otherwise:</p><pre><code class="ml">let validateSession = (next, request) =&gt;
  switch (request |&gt; Request.cookies |&gt; List.assoc_opt(&quot;SESSION&quot;)) {
  | Some(_) =&gt; next(request)
  | None =&gt; `Unauthorized |&gt; Response.of_status |&gt; Lwt.return
  };</code></pre><p>This filter gets the request cookies, looks for the <code>SESSION</code> cookie (the cookies are represented as just a list of pairs of cookie names and values), and calls the next request in the pipeline if it was found. Otherwise it sends back the unauthorized error response.</p><h3 id="updating-the-request-context"><a href="#updating-the-request-context" class="anchor"></a>Updating the request context</h3><p>Although interesting, this filter is ultimately not very helpful, because although it retrieves the session cookie it actually just throws it away again after doing its check. It doesn't pass it forward to the <code>next</code> service in the pipeline. The next service will now need to check for the cookie's presence <i>again</i>, despite the filter having already done that.</p><p>Fortunately, there's a better way--we can actually pass the session cookie's value to the next request, by using the request <i>context</i>. The context is a generically-typed field in the request record, and can thus contain any value. The nice thing about this is that we can put specifically the session cookie's value which we already extracted:</p><pre><code class="ml">let validateSession = (next, request) =&gt;
  switch (request |&gt; Request.cookies |&gt; List.assoc_opt(&quot;SESSION&quot;)) {
  | Some(session) =&gt;
    request |&gt; Request.set_context(session) |&gt; next
  | None =&gt; `Unauthorized |&gt; Response.of_status |&gt; Lwt.return
  };</code></pre><p>This filter updates the request's <code>ctx</code> field (immutably, i.e. creating a new request value) and feeds it to the <code>next</code> service. The next service in the pipeline can now access the context by using the <a href="../ReWeb__Server/Request/index.html#val-context"><code>ReWeb.Request.context</code></a> function.</p><h4 id="preserving-existing-context"><a href="#preserving-existing-context" class="anchor"></a>Preserving existing context</h4><p>However, there is an issue with simply setting the context like we have above: there might be some existing value in the context already, and updating it loses that. Fortunately, you will get a typechecker error if you ever do that inadvertently, because the subsequent filters and services would no longer typecheck accessing the previous context. But if you would still like to keep the previous context, ReWeb has a convention: wrapping it in an object. For example:</p><pre><code class="ml">let validateSession = (next, request) =&gt;
  switch (request |&gt; Request.cookies |&gt; List.assoc_opt(&quot;SESSION&quot;)) {
  | Some(session) =&gt;
    let ctx = {
      as _;
      pub prev = Request.context(request);
      pub session = session;
    };
    request |&gt; Request.set_context(ctx) |&gt; next;
  | None =&gt; `Unauthorized |&gt; Response.of_status |&gt; Lwt.return
  };</code></pre><p>This creates an <a href="https://reasonml.github.io/docs/en/object">object</a> literal which has two jobs:</p><ul><li>Contain the previous context, in a method named <code>prev</code></li><li>Contain the current session value, in a method named <code>session</code></li></ul><p>Then, it updates the request with this object which becomes the new context, and calls the <code>next</code> service with the updated request.</p><p>This is one of the few times in Reason when it's very convenient to use its object system: when you want to whip up a container to hold named values of any types, without having to declare its type first.</p><p>To be honest though, you will get a typechecker error any time you change a request pipeline's filters. In my humble opinion this is a good thing because it forces you to examine the pipeline from start to finish and ensure that it's getting exactly the context it needs from its filter chain.</p><h4 id="accessing-wrapped-contexts"><a href="#accessing-wrapped-contexts" class="anchor"></a>Accessing wrapped contexts</h4><p>The service which comes after this filter will want to access its values. It can do so with:</p><ul><li><code>Request.context(request)#session</code> to get the session cookie value</li><li><code>Request.context(request)#prev</code> to get the value of the previous context. In fact, if you want to access contexts that were wrapped farther back in the filter chain, you would have to do <code>Request.context(request)#prev#prev...</code>.</li></ul><h3 id="running-a-filter-after-a-request"><a href="#running-a-filter-after-a-request" class="anchor"></a>Running a filter after a request</h3><p>Filters can not only run before and modify requests, but also run after and modify responses. For example, suppose you want to add a <code>X-Response-Time-S</code> header to every response to inform clients how long it took in seconds for your server to create a response. You would need to:</p><ul><li>Capture the current time as the start time</li><li>Actually call the <code>next</code> service with the <code>request</code> and get its response promise</li><li>Map over the response promise and inside that, capture the current time as the end time, calculate the difference, and add a header containing it</li></ul><p>Here's the implementation:</p><pre><code class="ml">let setResponseTime = (next, request) =&gt; {
  let startTime = Unix.gettimeofday();
  let addHeader = Response.add_header(
    ~name=&quot;x-response-time-s&quot;,
    ~value=string_of_float(Unix.gettimeofday() -. startTime),
  );

  request |&gt; next |&gt; Lwt.map(addHeader);
};</code></pre><p><i>Note</i> that, because of the way the <code>Response.add_header</code> function is defined, you can partially apply it without the actual <code>response</code> argument and that will give you the function that you can pass in to <code>Lwt.map</code>. At a higher level, you can think of <code>addHeader</code> as an 'action' that you do to the response (even though it is really a partially-applied function).</p><h2 id="inserting"><a href="#inserting" class="anchor"></a>Inserting a filter in the request-response pipeline</h2><p>To set up a filter to run before a service, call the service with the filter. For example, suppose you have the following service:</p><pre><code class="ml">let hello = _ =&gt; &quot;Hello, World!&quot; |&gt; Response.of_text |&gt; Lwt.return;</code></pre><p>You can <i>compose</i> the filter with a service, e.g.:</p><pre><code class="ml">noFilter(hello)</code></pre><p>Typically I use the <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Stdlib.html#VAL(@@)"><code>@@</code></a> operator to compose filters:</p><pre><code class="ml">noFilter @@ hello</code></pre><p>This sort of looks like a data flow. As you compose more filters together you can sort of visualize them as a left-to-right series of filtering actions that happen before the service runs. Here's a more complex example:</p><pre><code class="ml">let hello = request =&gt; {
  let _: Yojson.Safe.t = Request.context(request)#prev;
  &quot;Hello, World!&quot; |&gt; Response.of_text |&gt; Lwt.return;
};

let test = Filter.body_json @@ Filter.basic_auth @@ hello;</code></pre><p>What's happening above, starting from the bottom up:</p><ul><li>We compose two filters and a service</li><li>The service accesses the context and then its wrapped <code>prev</code> method to get the request body JSON and typechecks that it actually is JSON. And this check happens at compile time!</li></ul><p>As you can see, a filter chain can be composed by following certain conditions:</p><ul><li>The previous filter in the chain needs to 'output' a context type that the next filter in the chain can handle</li><li>Any filter that accesses the request body needs to be <i>first</i> in the filter chain</li><li>The service at the end of the filter chain may access the context in a way that type-checks</li></ul><p>These conditions however are enforced at compile time (provided the filters are implemented correctly), so you don't need to worry about getting them wrong.</p><h3 id="inserting-a-filter-for-a-specific-scope-in-the-router"><a href="#inserting-a-filter-for-a-specific-scope-in-the-router" class="anchor"></a>Inserting a filter for a specific scope in the router</h3><p>Because of the design of routers (i.e. servers), you can plug in filters at specific route scopes. Suppose you want to parse all request bodies as JSON but only at the <code>/api/...</code> scope. You can write a router specifically for that scope:</p><pre><code class="ml">let getHeroes = request =&gt; {
  let _: Yojson.Safe.t = Request.context(request);
  &quot;Heroes!&quot; |&gt; Response.of_text |&gt; Lwt.return;
};

let notFound = _ =&gt; `Not_found |&gt; Response.of_status |&gt; Lwt.return;

let apiServer =
  fun
  | (`GET, [&quot;heroes&quot;]) =&gt; getHeroes
  | _ =&gt; notFound;</code></pre><p>The <code>apiServer</code> doesn't actually know that it's serving the <code>/api/...</code> scope. Its services simply access the request context JSON and that typechecks, because...</p><pre><code class="ml">let server =
  fun
  | (meth, [&quot;api&quot;, ...path]) =&gt;
    Filter.body_json @@ apiServer @@ (meth, path)
  | _ =&gt; notFound;</code></pre><p>Its parent <code>server</code> pattern-matches on all paths starting with <code>api</code> and passes them forward (along with the request method) to the <code>apiServer</code>, but only after applying the <code>body_json</code> filter so that all <code>apiServer</code> services will see requests with a context containing the body JSON.</p><h2 id="the-reweb-filters"><a href="#the-reweb-filters" class="anchor"></a>The ReWeb filters</h2><p>ReWeb ships with some built-in filters, which you can see in the <a href="../ReWeb/Filter/index.html"><code>ReWeb.Filter</code></a> module. This section shows how to use them.</p><p><i>Note</i> that, as mentioned in the previous section, the ReWeb filters are written in a type-safe and composeable way. For example, the type signature of the <a href="../ReWeb__Server/Filter/index.html#val-body_json"><code>ReWeb.Filter.body_json</code></a> filter:</p><pre><code class="ml">val body_json : (unit, Yojson.Safe.t, [&gt; Response.http]) t</code></pre><p>If we compare the type parameters to their formal parameter names:</p><ul><li><code>'ctx1</code> = <code>unit</code></li><li><code>'ctx2</code> = <code>Yojson.Safe.t</code></li><li><code>'resp</code> = <code>[&gt; Response.http]</code></li></ul><p>This tells us that the filter starts with an 'input' context type of <code>unit</code> and transforms it into an 'output' context type of <code>Yojson.Safe.t</code> (i.e. a JSON document). And the third type parameter says that the response type is HTTP (as opposed to a WebSocket).</p><p>This means that this must be either first in the filter chain or must come after filters that don't change the context.</p><h3 id="cors-protection"><a href="#cors-protection" class="anchor"></a>CORS protection</h3><p>This filter takes any context and outputs the same context, with the <code>Access-Control-Allow-Origin</code> and <code>Vary</code> headers correctly added to the response:</p><pre><code class="ml">// Equivalent to '*':
cors(Header.AccessControlAllowOrigin.All) @@ service

// A specific origin:
cors(
  Header.AccessControlAllowOrigin.One(&quot;http://localhost:8080&quot;)
) @@
service</code></pre><h3 id="content-security-policy"><a href="#content-security-policy" class="anchor"></a>Content Security Policy</h3><p>This filter takes any context and outputs the same context, with the <code>Content-Security-Policy</code> header and optionally the <code>Report-To</code> headers correctly added to the response:</p><pre><code class="ml">csp(Header.ContentSecurityPolicy.make()) @@ service</code></pre><p>See the <a href="../ReWeb__Header/ContentSecurityPolicy/index.html"><code>ContentSecurityPolicy</code></a> docs for details of creating policies.</p><h3 id="http-strict-transport-security"><a href="#http-strict-transport-security" class="anchor"></a>HTTP Strict Transport Security</h3><p>This filter takes any context and outputs the same context, with the <code>Strict-Transport-Security</code> header added to the response:</p><pre><code class="ml">hsts(Header.StrictTransportSecurity.make(100_000)) @@ service</code></pre><h3 id="basic-authentication"><a href="#basic-authentication" class="anchor"></a>Basic authentication</h3><p>This filter takes any context and outputs a context containing the username and password taken from the request's basic auth credentials:</p><pre><code class="ml">basic_auth @@ service</code></pre><p>It responds with an error status response if it can't understand the auth header.</p><h3 id="bearer-authentication"><a href="#bearer-authentication" class="anchor"></a>Bearer authentication</h3><p>Takes any context and outputs a context containing bearer token:</p><pre><code class="ml">bearer_auth @@ service</code></pre><p>Error behaviour is like <code>basic_auth</code>.</p><h3 id="decode-a-web-form-from-request-body"><a href="#decode-a-web-form-from-request-body" class="anchor"></a>Decode a web form from request body</h3><p>Takes a <code>unit</code> context (i.e. a context that has not been touched by any other filter) and outputs a context of a custom type that you specify. The reason it needs a unit context is that it needs to fully read the request body to decode it, and wants to ensure nothing else has already read the body.</p><p>For example to decode the following form in a request body into a strongly-typed value:</p><pre><code class="ml">id=1&amp;name=Bob</code></pre><p>You can declare the type and its corresponding form decoder:</p><pre><code class="ml">type user = {id: int, name: string};

let user = (id, name) =&gt; {id, name};
let userForm = Form.(make(Field.[int(&quot;id&quot;), string(&quot;name&quot;)], user));
body_form(userForm) @@ service</code></pre><p>Note the placements of the parentheses that locally open the <a href="../ReWeb/Form/index.html"><code>ReWeb.Form</code></a> and <a href="../ReWeb/Form/Field/index.html"><code>ReWeb.Form.Field</code></a> modules. These expose the <code>make</code> function to create a form and the field list type (which you create using the square brackets), and also the field specifier functions like <code>int</code>, <code>string</code> which you use to describe the fields--specifically their types and names.</p><p>Finally you pass in the <code>user</code> constructor to the <code>make</code> function which actually creates the typed <code>user</code> value. The typechecker verifies that the user constructor function matches up with the types declared for the form.</p><h3 id="parse-request-body-json"><a href="#parse-request-body-json" class="anchor"></a>Parse request body JSON</h3><p>Takes a unit context and outputs a body JSON context:</p><pre><code class="ml">body_json @@ service</code></pre><h3 id="decode-request-body-json"><a href="#decode-request-body-json" class="anchor"></a>Decode request body JSON</h3><p>Takes a body JSON context and a JSON decoder and outputs a context of a custom type:</p><pre><code class="ml">let jsonToUser = json =&gt; ...;
body_json_decode(user_of_yojson) @@ service</code></pre><p>You can hand-write a decoder function or use <a href="https://github.com/ocaml-ppx/ppx_deriving_yojson">ppx_deriving_yojson</a> to derive it from your type definition.</p><h3 id="get-request-body-as-a-string"><a href="#get-request-body-as-a-string" class="anchor"></a>Get request body as a string</h3><p>Takes a unit context and outputs a context of a string containing the request body:</p><pre><code class="ml">body_string @@ service</code></pre><h3 id="set-response-cache-policy"><a href="#set-response-cache-policy" class="anchor"></a>Set response cache policy</h3><p>Takes any context and returns that context unmodified but with a <code>cache-control</code> header added to the response. For example to set the response to cache anywhere (publicly) for ten minutes:</p><pre><code class="ml">cache_control(Header.CacheControl.public(~max_age=600)) @@ service</code></pre><h3 id="upload-files-&amp;-decode-a-multipart-form"><a href="#upload-files-&amp;-decode-a-multipart-form" class="anchor"></a>Upload files &amp; decode a multipart form</h3><p>Takes a unit context and returns a context of a custom type in the same way as the body form decoder filter, and <i>additionally</i> saves any uploaded files sent in the multipart form using the specified function to derive the file names:</p><pre><code class="ml">let path = (~filename, name) =&gt; &quot;./form_&quot; ++ name ++ &quot;_&quot; ++ filename;
multipart_form(userForm, path) @@ service</code></pre><p>The <code>filename</code> passed in to the <code>path</code> function is stripped of any directory path beforehand so there's no risk of someone saving a file in an unexpected directory.</p><h3 id="decode-form-from-request-uri-query"><a href="#decode-form-from-request-uri-query" class="anchor"></a>Decode form from request URI query</h3><p>Takes any context and returns a context containing a URI query decoded into a strong type using the same form decoders as above. Also returns the previous context wrapped inside the new context. E.g.:</p><pre><code class="ml">query_form(userForm) @@ service</code></pre></header></div></body></html>