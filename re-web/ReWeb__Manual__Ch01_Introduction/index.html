<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ReWeb__Manual__Ch01_Introduction (re-web.ReWeb__Manual__Ch01_Introduction)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">re-web</a> &#x00BB; ReWeb__Manual__Ch01_Introduction</nav><h1>Module <code>ReWeb__Manual__Ch01_Introduction</code></h1><p>ReWeb is a web framework for ReasonML. It is meant to enable web programming in a simple, functional (declarative) style. This style is inspired by the paper <a href="https://monkey.org/~marius/funsrv.pdf">'Your Server as a Function'</a> by Marius Eriksen. The fundamental concept of ReWeb is:</p><pre><code class="ml">request =&gt; promise of response</code></pre><h2 id="services"><a href="#services" class="anchor"></a>Services</h2><p>Like other libraries inspired by this style, ReWeb aims to model the web's request-response paradigm with types that represent the request, the response, and the asynchronous nature of the response (hence 'promise of response').</p><p>Concretely, we call the <code>request =&gt; promise of response</code> type a <i>service</i>, and a pairing of HTTP method (e.g. <code>`GET</code>) and path components (e.g. <code>[&quot;api&quot;]</code> to represent <code>/api</code>) a <i>route</i>. A ReWeb server is a single function that takes a route as input, and returns a service. E.g.:</p><pre><code class="ml">open ReWeb;

let helloService = _request =&gt; Lwt.return(Response.of_text(&quot;Hello&quot;));
let server = _route =&gt; helloService;
let () = Server.serve(server);</code></pre><p><code>Lwt.return</code> returns a fulfilled promise containing its argument, and <a href="../ReWeb/Server/index.html#val-serve"><code>ReWeb.Server.serve</code></a> starts running the server.</p><h2 id="routes"><a href="#routes" class="anchor"></a>Routes</h2><p>You can match routes more precisely:</p><pre><code class="ml">let notFoundService = _ =&gt;
  Lwt.return(Response.of_text(~status=`Not_found, &quot;Not found&quot;));

let server = fun
  | (`GET, [&quot;hello&quot;]) =&gt; helloService
  | _ =&gt; notFoundService;</code></pre><p>This server will respond with <code>hello</code> specifically at the <code>/hello</code> endpoint, and a 404 response at any other endpoint.</p><p>See <a href="../ReWeb/Server/index.html"><code>ReWeb.Server</code></a> for more details on servers.</p><h2 id="filters"><a href="#filters" class="anchor"></a>Filters</h2><p>The final important top-level concept to understand is <i>filters</i>, which are service transformer functions. Filters are functions of type (roughly):</p><pre><code class="ml">service =&gt; service</code></pre><p>Filters are essentially like middleware in ExpressJS and other web frameworks; they plug in to the request pipeline and change requests or responses in certain ways. You can imagine it like a data flow:</p><pre><code class="ml">client =&gt;
request =&gt;
[filter1 =&gt; ... =&gt; filterN =&gt;]
service =&gt;
promise of response</code></pre><p>As you can tell, zero or more filters can be plugged into the pipeline before the service. By the time the service runs, the filters that ran before it might have performed authentication using the request's HTTP <code>Authorization</code> header, read the request body, safely decoded it from a web form into a strongly-typed value, and put the value in the request's 'context' (we will cover that in a later chapter). If any of those filters failed, typically they would short-circuit the pipeline and respond with a 400 Bad Request, 403 Forbidden, or other appropriate response status.</p><p>One of the key benefits of ReWeb filters is that they are type-safe. Specifically this means that their 'input context' and 'output context' types are exposed at the type level, and only filters and services which have compatible input context/output context types can plug together. Those that don't, will result in a compile error.</p><p>So concretely this means that a service that tries to get the auth token and the decoded form body from the request context, will only compile if the filters which do those jobs were actually plugged in to the request pipeline before it.</p><p>A lot of ReWeb's functionality comes from filters, ones that ship with ReWeb itself, or ones you write yourself, or even get from a third party. If you're wondering how to do something, chances are you can do it with a filter. Check <code>Ch05_Filters</code> to start.</p><h2 id="promises-(lwt)"><a href="#promises-(lwt)" class="anchor"></a>Promises (Lwt)</h2><p>The ReWeb stack is completely asychronous and runs using a promise runtime. The concrete implementation used currently is <a href="http://ocsigen.org/lwt/4.1.0/manual/manual">Lwt</a>, which stands for 'light-weight threads'. Lwt provides cooperative multi-tasking via promises (a.k.a. 'threads') and a runtime that implements the cooperative scheduler and event loop, a lot like NodeJS but with some additional powers.</p><p>In programming ReWeb the user should expect to deal with Lwt promises fairly frequently. Fortunately the parts of Lwt that should be used most often should be familiar:</p><p><code>Lwt.return(x)</code> is like JavaScript's <code>Promise.resolve(x)</code></p><pre><code class="ml">let getInfo = productId =&gt; {
  open Lwt.Syntax;

  let* inventory = getInventory(productId);
  let+ price = getPrice(productId);

  mergeInventoryPrice(inventory, price);
};</code></pre><p>...is like JavaScript's</p><pre><code class="ml">const getInfo = async (productId) =&gt; {
  const inventory = await getInventory(productId);
  const price = await getPrice(productId);

  return mergeInventoryPrice(inventory, price);
};</code></pre><p>Note that you don't have to mark Reason functions as <code>async</code>--the typechecker infers that automatically from the function return type.</p></header></div></body></html>