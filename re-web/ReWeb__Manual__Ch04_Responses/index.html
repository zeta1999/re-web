<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ReWeb__Manual__Ch04_Responses (re-web.ReWeb__Manual__Ch04_Responses)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">re-web</a> &#x00BB; ReWeb__Manual__Ch04_Responses</nav><h1>Module <code>ReWeb__Manual__Ch04_Responses</code></h1><p>Sending responses forms perhaps the largest portion of the ReWeb API surface area. While requests are relatively simple, responses can be created and accessed in a variety of ways. The key point to remember is that ReWeb responses are the <i>same data type</i> as <a href="../ReWeb/Client/index.html"><code>ReWeb.Client</code></a> responses. In other words, if you make a web client request in ReWeb as part of handling your client's request, you can potentially unwrap and send back exactly that response to <i>your</i> client.</p><p>That said, there is a slight nuance. In ReWeb you can write a response that is a standard HTTP response, or one that is actually a WebSocket server. The latter will cause a WebSocket connection to be established and handled as specified. These are modelled at the type level:</p><pre><code class="ml">type t('resp) = [&gt; http | websocket] as 'resp;</code></pre><p>This is saying that when you have a <code>Response.t('resp)</code>, it could be an HTTP <i>or</i> a WebSocket response. This level of type detail ensures that the correct operations will work on HTTP or WebSocket responses.</p><h2 id="http-responses"><a href="#http-responses" class="anchor"></a>HTTP responses</h2><p>HTTP responses are defined as an 'envelope' and a body. The envelope specifies the response headers and status. The body is the same body type we came across in Chapter 3--all HTTP bodies in ReWeb are handled with the same data type.</p><h3 id="creation"><a href="#creation" class="anchor"></a>Creation</h3><p>You can create HTTP responses in a variety of ways:</p><ul><li>By content type: text, JSON, HTML, binary</li><li>From a file in the filesystem</li><li>From a 'view' that is a rendering function</li><li>By status code</li><li>With a 301 redirect</li></ul><p>All response creator functions start with the prefix <code>of_</code> and all accept the response status and headers to set as optional parameters with reasonable defaults. There are lots of examples in the <code>bin/</code> directory but the following sections have some pertinent details:</p><h4 id="content-type"><a href="#content-type" class="anchor"></a>Content type</h4><p>These convenience functions, like <code>of_binary</code>, <code>of_html</code>, <code>of_json</code>, etc., set the <code>content-type</code> response header correctly. As mentioned, they also take the response status, headers, and cookies as optional parameters. They will allow you to pass in the <code>content-type</code> header as well--it's up to you to manage that.</p><h4 id="static-file"><a href="#static-file" class="anchor"></a>Static file</h4><p>The <a href="../ReWeb/Response/index.html#val-of_file"><code>ReWeb.Response.of_file</code></a> function is meant to be used for sending out static files from the server's filesystem as fast as possible. Refer to the API doc for details.</p><h4 id="view"><a href="#view" class="anchor"></a>View</h4><p>The <a href="../ReWeb/Response/index.html#val-of_view"><code>ReWeb.Response.of_view</code></a> function allows rendering a view. What ReWeb calls a view, may look slightly different than you are used to. A ReWeb view is a function that takes a 'printer' function (I typically call it <code>p</code>) and calls it one or more times with strings to render.</p><p>Here's what a simple view might look like:</p><pre><code class="ml">let helloWorld = p =&gt; {
  p(&quot;Hello, &quot;);
  p(&quot;World!&quot;);
};

helloWorld |&gt; Response.of_view |&gt; Lwt.return;</code></pre><p>The printer function pushes its input string out into the response body stream. This ensures that rendering happens as fast as possible.</p><p>Of course the above view is not very useful, because you could easily have sent a static text response. Views get more useful when you give them some parameters:</p><pre><code class="ml">let helloName = (~name, p) =&gt; {
  p(&quot;Hello, &quot;);
  p(name);
  p(&quot;!&quot;);
};

helloName(~name=&quot;Bob&quot;) |&gt; Response.of_view |&gt; Lwt.return;</code></pre><p>This view interpolates the <code>name</code> parameter into the response body. It works because of Reason's automatic function currying. When you call <code>helloName(~name=&quot;Bob&quot;)</code>, you get back a partially-applied function with the exact type that <code>of_view</code> needs. This will work with any number of parameters as long as the <code>p</code> parameter is the last one in the function.</p><p>Note that views can be any content. ReWeb doesn't care about what's inside them--text, HTML, JSON, whatever. It just pushes out strings to the response body stream.</p><p>I am planning to include a 'view compiler' in ReWeb to make writing views easier. In the future views should look like template files that you might come across in other frameworks. When your ReWeb project is built, these template files will be compiled into the view functions you see above. This will make the template files type-safe as well.</p><h4 id="status-code"><a href="#status-code" class="anchor"></a>Status code</h4><p><a href="../ReWeb/Response/index.html#val-of_status"><code>ReWeb.Response.of_status</code></a> is a convenience function to help you quickly return a standard boilerplate status message. See the API doc for details.</p><h4 id="redirect"><a href="#redirect" class="anchor"></a>Redirect</h4><p><a href="../ReWeb/Response/index.html#val-of_redirect"><code>ReWeb.Response.of_redirect</code></a> is a convenience function to respond with a 301 Redirect status to a given location.</p><h3 id="accessing"><a href="#accessing" class="anchor"></a>Accessing</h3><p>The response accessor functions allow you to get and set headers, get cookies, and get the response body. Moreover, they only work on the specific types of responses for which they are appropriate. For example, you can get a header from <i>any</i> response (HTTP or WebSocket):</p><pre><code class="ml">let contentType = Response.header(&quot;content-type&quot;, anyResponse);</code></pre><p>However, you can only get the <i>body</i> from an HTTP response:</p><pre><code class="ml">let body = Response.body(httpResponse);</code></pre><p>As mentioned above this is enforced at the type level, and you will get a type error if these rules are not followed.</p><h2 id="websocket-responses"><a href="#websocket-responses" class="anchor"></a>WebSocket responses</h2><p>The <a href="../ReWeb/Response/index.html#val-of_websocket"><code>ReWeb.Response.of_websocket</code></a> function returns specifically a WebSocket (WS) response. It requires you to pass in a <code>handler</code> function (and optional response headers). The handler function returns a promise that should run for the lifetime of the WS. The lifetime of the handler's promise, determines the lifetime of the WS from the server side. Here's a simple example of a WS that sends a single message to the client and then exits immediately:</p><pre><code class="ml">let ws = Response.of_websocket((_pull, push) =&gt;
  &quot;Hello, World!&quot; |&gt; push |&gt; Lwt.return
);</code></pre><p>ReWeb calls the handler function with two functions: <code>pull</code> and <code>push</code>. These functions let you send and receive messages to/from the client while inside the WS handler's function body. Pushing a message is synchronous and instant. (That's why you can send its result into <code>Lwt.return</code> to resolve the handler promise immediately.)</p><p><i>Pulling</i> a message from the WS is asynchronous because the client may not have sent a message yet. In fact, they may not send a message for a long time, if ever. Hence the <code>pull</code> function actually needs you to tell it how long to wait for a message--<code>pull(floatSeconds)</code>, and returns a promise--<code>Lwt.t(result(string, Response.pull_error))</code>, representing the fact that it's asynchronous and that it might have timed out and hence it didn't get a message.</p><p>Here's an example of pulling:</p><pre><code class="ml">let ws = Response.of_websocket((pull, _push) =&gt;
  1.
  |&gt; pull
  |&gt; Lwt.map(fun
      | Ok(string) =&gt; print_endline(string)
      | _ =&gt; print_endline(&quot;(Timed out or connection closed)&quot;)
    );</code></pre><p>This handler pulls a message from the connection, waiting for one second maximum. Then, because it gets back a promise, it maps over the promise to return the required type, <code>Lwt.t(unit)</code>, by just printing out whatever string it got (or an error message). By doing so it exits and closes the WS.</p><h3 id="continuously-running-handlers"><a href="#continuously-running-handlers" class="anchor"></a>Continuously-running handlers</h3><p>You probably noticed that in both of the above examples, the handler exited after doing just one thing, but in a normal WS connection you actually want the handler to keep running. You can do this with a ReWeb handler by using <a href="https://reasonml.github.io/docs/en/function.html#recursive-functions">recursion</a>. For example:</p><pre><code class="ml">let rec handler = (pull, push) =&gt; {
  open Lwt.Syntax;
  let* message = pull(2.);

  switch (Stdlib.Result.map(String.trim, message)) {
  | Ok(&quot;close&quot;) | Error(`Connection_close) =&gt; Lwt.return_unit
  | Ok(message) =&gt;
    push(message);
    handler(pull, push);
  | Error(_) =&gt; handler(pull, push)
  };
};

let ws = Response.of_websocket(handler);</code></pre><p>In this example, <code>handler</code> is recursive (defined with <code>let rec</code>) and calls itself to keep the promise running continuously. The promise polls for a new message every two seconds, checks if the message is 'close' (or if the client unexpectedly just closed the connection) and if so, exits the handler. Otherwise it echoes the message and keeps going.</p><h3 id="handlers-with-internal-state"><a href="#handlers-with-internal-state" class="anchor"></a>Handlers with internal state</h3><p>Since a handler just has to return a function that looks like <code>(pull, push) =&gt; Lwt.t(unit)</code> (roughly), you can actually create handlers that have <i>more</i> parameters and then call them with some initial values. This is the same 'trick' (partial application) we're using to pass parameters to views. Here's an example:</p><pre><code class="ml">let rec handler = (~doTimes, pull, push) =&gt;
  if (doTimes == 0) {
    Lwt.return_unit;
  } else {
    open Lwt.Syntax;
    let* message = pull(2.);

    switch (message) {
    | Ok(message) =&gt;
      push(message);
      handler(~doTimes=pred(doTimes), pull, push);
    | Error(`Connection_close) =&gt; Lwt.return_unit
    | Error(_) =&gt; handler(doTimes, pull, push)
    };
  };

let ws = Response.of_websocket(handler(~doTimes=5));</code></pre><p>In this example we just echo incoming messages but only 5 times, after which we close the connection. We also exit the handler, like before, if the client unexpectedly closes the connection.</p><p><i>Warning:</i> it's extremely important to let the handler exit as soon as possible from the <code>| Error(`Connection_close) =&gt; ...</code> branch. This error message is meant to specifically allow some cleanup before exiting the handler, but you definitely don't want to keep looping and send the handler into an infinite loop once the connection is closed.</p><p>Notice how the handler maintains its own internal state by using the recursive call to pass in a different value of <code>doTimes</code>. <code>pred</code> is a built-in standard library function; it returns the 'predecessor' (i.e. one less) of the integer passed to it.</p></header></div></body></html>