<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ReWeb__Response (re-web.ReWeb__Response)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">re-web</a> &#x00BB; ReWeb__Response</nav><h1>Module <code>ReWeb__Response</code></h1><p>For the response functions below, <code>status</code> defaults to <code>`OK</code> unless otherwise noted, and the <code>cookies</code> parameter is converted into response headers and merged with the <code>headers</code> parameter. There is therefore a chance of duplication which you will have to watch out for.</p></header><div class="spec module" id="module-Header"><a href="#module-Header" class="anchor"></a><code><span class="keyword">module</span> <a href="Header/index.html">Header</a>: { ... };</code></div><dl><dt class="spec type" id="type-headers"><a href="#type-headers" class="anchor"></a><code><span class="keyword">type</span> headers</code><code> = list(<span>(string, string)</span>)</code>;</dt><dd><p>a header <code>X-Client-Id: 1</code> is represented as: <code>[(&quot;x-client-id&quot;, &quot;1&quot;)]</code>.</p></dd></dl><dl><dt class="spec type" id="type-status"><a href="#type-status" class="anchor"></a><code><span class="keyword">type</span> status</code><code> = Httpaf.Status.t</code>;</dt><dd><p>See <a href="https://b0-system.github.io/odig/doc@odoc.default/httpaf/Httpaf/Status/index.html">Httpaf.Status</a> for valid statuses.</p></dd></dl><dl><dt class="spec type" id="type-http"><a href="#type-http" class="anchor"></a><code><span class="keyword">type</span> http</code> = <code>[ </code><table class="variant"><tr id="type-http.HTTP" class="anchored"><td class="def constructor"><a href="#type-http.HTTP" class="anchor"></a><code>| </code><code>`HTTP(<span>(Httpaf.Response.t, Piaf.Body.t)</span>)</code></td></tr></table><code> ]</code>;</dt><dt class="spec type" id="type-pull_error"><a href="#type-pull_error" class="anchor"></a><code><span class="keyword">type</span> pull_error</code> = <code>[ </code><table class="variant"><tr id="type-pull_error.Empty" class="anchored"><td class="def constructor"><a href="#type-pull_error.Empty" class="anchor"></a><code>| </code><code>`Empty</code></td><td class="doc"><p>The incoming message stream is empty.</p></td></tr><tr id="type-pull_error.Timeout" class="anchored"><td class="def constructor"><a href="#type-pull_error.Timeout" class="anchor"></a><code>| </code><code>`Timeout</code></td><td class="doc"><p>Could not get a message from the stream within the given timeout.</p></td></tr><tr id="type-pull_error.Connection_close" class="anchored"><td class="def constructor"><a href="#type-pull_error.Connection_close" class="anchor"></a><code>| </code><code>`Connection_close</code></td><td class="doc"><p>Connection was closed by the client. <b>Warning:</b> you must exit the WebSocket handler as soon as possible when this happens. Otherwise, you will be in an infinite loop waiting for messages that will never arrive.</p></td></tr></table><code> ]</code>;</dt><dd><p>Possible issues with pulling a message from the incoming messages stream.</p></dd></dl><dl><dt class="spec type" id="type-pull"><a href="#type-pull" class="anchor"></a><code><span class="keyword">type</span> pull</code><code> = float <span>=&gt;</span> Lwt_result.t<span>(string, <a href="index.html#type-pull_error">pull_error</a>)</span></code>;</dt><dd><p><code>pull(timeout_s)</code> asynchronously gets the next message from the WebSocket if there is any, with a timeout in seconds of <code>timeout_s</code>. If it doesn't time out it returns <code>Some string</code>, otherwise <code>None</code>.</p></dd></dl><dl><dt class="spec type" id="type-push"><a href="#type-push" class="anchor"></a><code><span class="keyword">type</span> push</code><code> = string <span>=&gt;</span> unit</code>;</dt><dd><p><code>push(response)</code> pushes the string <code>response</code> to the WebSocket client.</p></dd></dl><dl><dt class="spec type" id="type-handler"><a href="#type-handler" class="anchor"></a><code><span class="keyword">type</span> handler</code><code> = <a href="index.html#type-pull">pull</a> <span>=&gt;</span> <a href="index.html#type-push">push</a> <span>=&gt;</span> Lwt.t(unit)</code>;</dt><dd><p><code>handler(pull, push)</code> is an asynchronous callback that manages the WS from the server side. The WS will shut down from the server side as soon as <code>handler</code> exits, so if you want to keep it open you need to make it call itself recursively. Because the call will be tail-recursive, OCaml's tail-call elimination takes care of stack memory use.</p></dd></dl><dl><dt class="spec type" id="type-websocket"><a href="#type-websocket" class="anchor"></a><code><span class="keyword">type</span> websocket</code> = <code>[ </code><table class="variant"><tr id="type-websocket.WebSocket" class="anchored"><td class="def constructor"><a href="#type-websocket.WebSocket" class="anchor"></a><code>| </code><code>`WebSocket(<span>(option(Httpaf.Headers.t), <a href="index.html#type-handler">handler</a>)</span>)</code></td></tr></table><code> ]</code>;</dt><dd><p>A WebSocket response.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t('resp)</code><code> = <span>[&gt; <a href="index.html#type-http">http</a> <span>| <a href="index.html#type-websocket">websocket</a></span> ]</span> <span class="keyword">as</span> 'resp</code>;</dt><dd><p>Response type, can be an HTTP or a WebSocket response. Many of the functions below work with either HTTP or WebSocket responses, and some with only one or the other. This is enforced at the type level.</p></dd></dl><dl><dt class="spec value" id="val-add_cookie"><a href="#val-add_cookie" class="anchor"></a><code><span class="keyword">let</span> add_cookie: <a href="../ReWeb__Header/SetCookie/index.html#type-t">ReWeb__Header.SetCookie.t</a> <span>=&gt;</span> <span>[&lt; <a href="index.html#type-http">http</a> <span>| <a href="index.html#type-websocket">websocket</a></span> ]</span> <span>=&gt;</span> <a href="index.html#type-t">t</a>(<span class="type-var">_</span>);</code></dt><dd><p><code>add_cookie(cookie, response)</code> returns a response with a cookie <code>cookie</code> added to the original <code>response</code>.</p></dd></dl><dl><dt class="spec value" id="val-add_cookies"><a href="#val-add_cookies" class="anchor"></a><code><span class="keyword">let</span> add_cookies: list(<a href="../ReWeb__Header/SetCookie/index.html#type-t">ReWeb__Header.SetCookie.t</a>) <span>=&gt;</span> <span>[&lt; <a href="index.html#type-http">http</a> <span>| <a href="index.html#type-websocket">websocket</a></span> ]</span> <span>=&gt;</span> <a href="index.html#type-t">t</a>(<span class="type-var">_</span>);</code></dt><dd><p><code>add_cookies(cookies, response)</code> returns a response with the <code>cookies</code> added to the original <code>response</code>.</p></dd></dl><dl><dt class="spec value" id="val-add_header"><a href="#val-add_header" class="anchor"></a><code><span class="keyword">let</span> add_header: <span>?&#8288;replace:bool</span> <span>=&gt;</span> <span>name:string</span> <span>=&gt;</span> <span>value:string</span> <span>=&gt;</span> <span>[&lt; <a href="index.html#type-http">http</a> <span>| <a href="index.html#type-websocket">websocket</a></span> ]</span> <span>=&gt;</span> <a href="index.html#type-t">t</a>(<span class="type-var">_</span>);</code></dt><dd><p><code>add_header(?replace, ~name, ~value, response)</code> returns a response with a header <code>name</code> with value <code>value</code> added to the original <code>response</code>. If the response already contains the <code>header</code>, then it is replaced only if <code>replace</code> is <code>true</code>, which is the default.</p></dd></dl><dl><dt class="spec value" id="val-add_headers"><a href="#val-add_headers" class="anchor"></a><code><span class="keyword">let</span> add_headers: <a href="index.html#type-headers">headers</a> <span>=&gt;</span> <span>[&lt; <a href="index.html#type-http">http</a> <span>| <a href="index.html#type-websocket">websocket</a></span> ]</span> <span>=&gt;</span> <a href="index.html#type-t">t</a>(<span class="type-var">_</span>);</code></dt><dd><p><code>add_headers(headers, response)</code> returns a response with the <code>headers</code> added to the end of the original <code>response</code>'s header list.</p></dd></dl><dl><dt class="spec value" id="val-add_headers_multi"><a href="#val-add_headers_multi" class="anchor"></a><code><span class="keyword">let</span> add_headers_multi: list(<span>(string, list(string))</span>) <span>=&gt;</span> <span>[&lt; <a href="index.html#type-http">http</a> <span>| <a href="index.html#type-websocket">websocket</a></span> ]</span> <span>=&gt;</span> <a href="index.html#type-t">t</a>(<span class="type-var">_</span>);</code></dt><dd><p><code>add_headers_multi(headers_multi, response)</code> returns a response with <code>headers_multi</code> added to the end of the original <code>response</code>'s header list.</p></dd></dl><dl><dt class="spec value" id="val-body"><a href="#val-body" class="anchor"></a><code><span class="keyword">let</span> body: <span>[&lt; <a href="index.html#type-http">http</a> ]</span> <span>=&gt;</span> Piaf.Body.t;</code></dt><dt class="spec value" id="val-cookies"><a href="#val-cookies" class="anchor"></a><code><span class="keyword">let</span> cookies: <span>[&lt; <a href="index.html#type-http">http</a> <span>| <a href="index.html#type-websocket">websocket</a></span> ]</span> <span>=&gt;</span> list(<a href="../ReWeb__Header/SetCookie/index.html#type-t">ReWeb__Header.SetCookie.t</a>);</code></dt><dt class="spec value" id="val-header"><a href="#val-header" class="anchor"></a><code><span class="keyword">let</span> header: string <span>=&gt;</span> <span>[&lt; <a href="index.html#type-http">http</a> <span>| <a href="index.html#type-websocket">websocket</a></span> ]</span> <span>=&gt;</span> option(string);</code></dt><dd><p><code>header(name, request)</code> gets the last value corresponding to the given header, if present.</p></dd></dl><dl><dt class="spec value" id="val-headers"><a href="#val-headers" class="anchor"></a><code><span class="keyword">let</span> headers: string <span>=&gt;</span> <span>[&lt; <a href="index.html#type-http">http</a> <span>| <a href="index.html#type-websocket">websocket</a></span> ]</span> <span>=&gt;</span> list(string);</code></dt><dd><p><code>headers(name, request)</code> gets all the values corresponding to the given header.</p></dd></dl><dl><dt class="spec value" id="val-of_binary"><a href="#val-of_binary" class="anchor"></a><code><span class="keyword">let</span> of_binary: <span>?&#8288;status:<a href="index.html#type-status">status</a></span> <span>=&gt;</span> <span>?&#8288;content_type:string</span> <span>=&gt;</span> <span>?&#8288;headers:<a href="index.html#type-headers">headers</a></span> <span>=&gt;</span> <span>?&#8288;cookies:list(<a href="../ReWeb__Header/SetCookie/index.html#type-t">ReWeb__Header.SetCookie.t</a>)</span> <span>=&gt;</span> string <span>=&gt;</span> <span>[&gt; <a href="index.html#type-http">http</a> ]</span>;</code></dt><dt class="spec value" id="val-of_file"><a href="#val-of_file" class="anchor"></a><code><span class="keyword">let</span> of_file: <span>?&#8288;status:<a href="index.html#type-status">status</a></span> <span>=&gt;</span> <span>?&#8288;content_type:string</span> <span>=&gt;</span> <span>?&#8288;headers:<a href="index.html#type-headers">headers</a></span> <span>=&gt;</span> <span>?&#8288;cookies:list(<a href="../ReWeb__Header/SetCookie/index.html#type-t">ReWeb__Header.SetCookie.t</a>)</span> <span>=&gt;</span> string <span>=&gt;</span> Lwt.t(<span>[&gt; <a href="index.html#type-http">http</a> ]</span>);</code></dt><dd><p><code>of_file(?status, ?content_type, ?headers, ?cookies, file_name)</code> responds with the contents of <code>file_name</code>, which is a relative or absolute path, with HTTP response code <code>status</code> and content-type header <code>content_type</code>.</p><p>If the file is not found, responds with a 404 Not Found status and an appropriate message.</p><p><i>Warning</i> this function maps the entire file into memory. Don't use it for files larger than memory.</p></dd></dl><dl><dt class="spec value" id="val-of_html"><a href="#val-of_html" class="anchor"></a><code><span class="keyword">let</span> of_html: <span>?&#8288;status:<a href="index.html#type-status">status</a></span> <span>=&gt;</span> <span>?&#8288;headers:<a href="index.html#type-headers">headers</a></span> <span>=&gt;</span> <span>?&#8288;cookies:list(<a href="../ReWeb__Header/SetCookie/index.html#type-t">ReWeb__Header.SetCookie.t</a>)</span> <span>=&gt;</span> string <span>=&gt;</span> <span>[&gt; <a href="index.html#type-http">http</a> ]</span>;</code></dt><dt class="spec value" id="val-of_http"><a href="#val-of_http" class="anchor"></a><code><span class="keyword">let</span> of_http: <span>status:<a href="index.html#type-status">status</a></span> <span>=&gt;</span> <span>headers:list(<span>(string, string)</span>)</span> <span>=&gt;</span> Piaf.Body.t <span>=&gt;</span> <span>[&gt; <a href="index.html#type-http">http</a> ]</span>;</code></dt><dd><p><code>of_http(~status, ~headers, body)</code> responds with an HTTP response composed of <code>status</code>, <code>headers</code>, and <code>body</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_json"><a href="#val-of_json" class="anchor"></a><code><span class="keyword">let</span> of_json: <span>?&#8288;status:<a href="index.html#type-status">status</a></span> <span>=&gt;</span> <span>?&#8288;headers:<a href="index.html#type-headers">headers</a></span> <span>=&gt;</span> <span>?&#8288;cookies:list(<a href="../ReWeb__Header/SetCookie/index.html#type-t">ReWeb__Header.SetCookie.t</a>)</span> <span>=&gt;</span> Yojson.Safe.t <span>=&gt;</span> <span>[&gt; <a href="index.html#type-http">http</a> ]</span>;</code></dt><dt class="spec value" id="val-of_redirect"><a href="#val-of_redirect" class="anchor"></a><code><span class="keyword">let</span> of_redirect: <span>?&#8288;content_type:string</span> <span>=&gt;</span> <span>?&#8288;body:string</span> <span>=&gt;</span> string <span>=&gt;</span> <span>[&gt; <a href="index.html#type-http">http</a> ]</span>;</code></dt><dd><p><code>of_redirect(?content_type, ?body, location)</code> responds with an HTTP redirect response to the new <code>location</code>, with an optional <code>content_type</code> (defaulting to <code>text/plain</code>) and <code>body</code> (defaulting to an empty body).</p></dd></dl><dl><dt class="spec value" id="val-of_status"><a href="#val-of_status" class="anchor"></a><code><span class="keyword">let</span> of_status: <span>?&#8288;content_type:<span>[ `text <span>| `html</span> ]</span></span> <span>=&gt;</span> <span>?&#8288;headers:<a href="index.html#type-headers">headers</a></span> <span>=&gt;</span> <span>?&#8288;cookies:list(<a href="../ReWeb__Header/SetCookie/index.html#type-t">ReWeb__Header.SetCookie.t</a>)</span> <span>=&gt;</span> <span>?&#8288;message:string</span> <span>=&gt;</span> <a href="index.html#type-status">status</a> <span>=&gt;</span> <span>[&gt; <a href="index.html#type-http">http</a> ]</span>;</code></dt><dd><p><code>of_status(?content_type, ?headers, ?cookies, ?message, status)</code> responds with a standard boilerplate response message based on the <code>content_type</code> and <code>status</code>. <code>content_type</code> defaults to <code>`text</code>. The boilerplate message can be overridden by <code>message</code> if present.</p></dd></dl><dl><dt class="spec value" id="val-of_text"><a href="#val-of_text" class="anchor"></a><code><span class="keyword">let</span> of_text: <span>?&#8288;status:<a href="index.html#type-status">status</a></span> <span>=&gt;</span> <span>?&#8288;headers:<a href="index.html#type-headers">headers</a></span> <span>=&gt;</span> <span>?&#8288;cookies:list(<a href="../ReWeb__Header/SetCookie/index.html#type-t">ReWeb__Header.SetCookie.t</a>)</span> <span>=&gt;</span> string <span>=&gt;</span> <span>[&gt; <a href="index.html#type-http">http</a> ]</span>;</code></dt><dt class="spec value" id="val-of_view"><a href="#val-of_view" class="anchor"></a><code><span class="keyword">let</span> of_view: <span>?&#8288;status:<a href="index.html#type-status">status</a></span> <span>=&gt;</span> <span>?&#8288;content_type:string</span> <span>=&gt;</span> <span>?&#8288;headers:<a href="index.html#type-headers">headers</a></span> <span>=&gt;</span> <span>?&#8288;cookies:list(<a href="../ReWeb__Header/SetCookie/index.html#type-t">ReWeb__Header.SetCookie.t</a>)</span> <span>=&gt;</span> <span>(<span>(string <span>=&gt;</span> unit)</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <span>[&gt; <a href="index.html#type-http">http</a> ]</span>;</code></dt><dd><p><code>of_view(?status, ?content_type, ?headers, ?cookies, view)</code> responds with a rendered body as per the <code>view</code> function. The <code>view</code> is a function that takes a 'printer' function (<code>string -&gt; unit</code>) as a parameter and 'prints' (i.e. renders piecemeal) strings to it. These strings are pushed out as they are rendered.</p><p>The difference from <code>of_html</code>, <code>of_binary</code>, and the other functions is that those hold the entire response in memory before sending it to the client, while <code>of_view</code> holds only each piece of the response as it is streamed out.</p></dd></dl><dl><dt class="spec value" id="val-of_websocket"><a href="#val-of_websocket" class="anchor"></a><code><span class="keyword">let</span> of_websocket: <span>?&#8288;headers:<a href="index.html#type-headers">headers</a></span> <span>=&gt;</span> <a href="index.html#type-handler">handler</a> <span>=&gt;</span> <span>[&gt; <a href="index.html#type-websocket">websocket</a> ]</span>;</code></dt><dd><p><code>of_websocket(?headers, handler)</code> is an open WebSocket response. Optionally you can pass along extra <code>headers</code> which will be sent to the client when opening the WS.</p><p><i>Warning</i> it can be a little tricky to write a completely asynchronous WebSocket handler correctly. Be sure to read the reference documentation above, and the manual, carefully.</p><p><i>Note</i> OCaml strings are un-encoded byte arrays, and ReWeb treats all incoming and outgoing WebSocket data as such--even if the client is sending UTF-8 encoded text format (see <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#Format">https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#Format</a>). It's up to you as the WebSocket handler writer to encode/decode them as necessary.</p></dd></dl><dl><dt class="spec value" id="val-status"><a href="#val-status" class="anchor"></a><code><span class="keyword">let</span> status: <span>[&lt; <a href="index.html#type-http">http</a> ]</span> <span>=&gt;</span> <a href="index.html#type-status">status</a>;</code></dt><dt class="spec value" id="val-status_code"><a href="#val-status_code" class="anchor"></a><code><span class="keyword">let</span> status_code: <span>[&lt; <a href="index.html#type-http">http</a> ]</span> <span>=&gt;</span> int;</code></dt></dl></div></body></html>