<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ReWeb__Manual__Ch02_Servers (re-web.ReWeb__Manual__Ch02_Servers)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">re-web</a> &#x00BB; ReWeb__Manual__Ch02_Servers</nav><h1>Module <code>ReWeb__Manual__Ch02_Servers</code></h1><p>A ReWeb server is a function that takes a route as input and returns a service as output. A route is a pair of HTTP method and path segment list, and a service is a function from a request to a promise of response.</p><h2 id="defining-a-server"><a href="#defining-a-server" class="anchor"></a>Defining a server</h2><p>One of the simplest possible servers:</p><pre><code class="ml">let server = _route =&gt; _request =&gt;
  Lwt.return(ReWeb.Response.of_text(&quot;Hello, World!&quot;));</code></pre><p>Because of Reason's auto-curried function syntax, this will normally be written:</p><pre><code class="ml">let server = (_route, _request) =&gt;
  &quot;Hello, World!&quot; |&gt; ReWeb.Response.of_text |&gt; Lwt.return;</code></pre><p>A server is not run immediately when it is created (because it is a function). Recall from above that the final output of the server is a <i>promise</i> of a response. In other words, servers are completely asynchronous from the top down. However when the server is supplied both a route and a request, it will run. This is done by the <code>Server.serve</code> function:</p><h2 id="running-a-server"><a href="#running-a-server" class="anchor"></a>Running a server</h2><pre><code class="ml">ReWeb.Server.serve(server);</code></pre><p>This is ReWeb's entry point into the application. The <code>server</code> would now be called with every incoming route and request.</p><h2 id="matching-routes"><a href="#matching-routes" class="anchor"></a>Matching routes</h2><p>A ReWeb server is also automatically a router. This is because its first parameter is a <code>route</code>, which is defined as a pair (tuple) of HTTP method, and path segment list. Both of these are pattern-matchable:</p><ul><li>An HTTP method is a polymorphic variant type defined with the valid HTTP verbs, e.g. <code>`GET</code>, <code>`POST</code>, <code>`DELETE</code>, and so on. You can see the <a href="https://b0-system.github.io/odig/doc@odoc.default/httpaf/Httpaf/Method/index.html">Httpaf.Method</a> module documentation for details.</li><li>A path segment list is a list of strings created by splitting up the request path into its segments: e.g. <code>/api/users/1</code> becomes <code>[&quot;api&quot;, &quot;users&quot;, &quot;1&quot;]</code>. Note that all path segments become strings, even the <code>1</code>. If you need it as an <code>int</code> you will need to convert it (with e.g. <code>int_of_string(id)</code>).</li></ul><p>Here's an example of a route being matched:</p><pre><code class="ml">let server = fun
  | (`GET, [&quot;api&quot;, &quot;users&quot;, id]) =&gt; getUser(id)
  | _ =&gt; notFound;</code></pre><p>The path is converted into the segment list by:</p><ul><li>Stripping away the query string if any</li><li>Converting to a string list with <code>String.split_on_char('/', path)</code></li><li>Stripping off the list head which would be an empty string because paths always start with <code>/</code>.</li></ul><p>So e.g. the index path <code>/</code> would be: <code>[&quot;&quot;]</code>. And <code>/docs/</code> would be: <code>[&quot;docs&quot;, &quot;&quot;]</code>.</p><p>When pattern-matching, all the normal rules of pattern matching in OCaml/ReasonML apply: matching literals, capturing parts or all of the matched pattern in bindings, as-patterns, or-patterns, and so on. Hence route matching is quite flexible.</p><p>Pattern-matched routes also offer two other big advantages:</p><ul><li>The compiler warns you if you forget to <i>exhaustively</i> handle routes, i.e. if you don't include a catch-all path at the bottom of the router</li><li>The compiler warns you if you handle the same route twice</li></ul><p>These features are quite difficult to get with other systems. We get them for 'free' with OCaml/Reason's compiler and the simple routing system used in ReWeb.</p><h2 id="scoping-routes"><a href="#scoping-routes" class="anchor"></a>Scoping routes</h2><p>Because servers are just functions, you can define more than one and call 'child' servers from 'parent' servers. The response returned from the child server is then returned from the parent. One very useful consequence of this is that you can scope child servers to specific route scopes. E.g.:</p><pre><code class="ml">let apiServer = fun
  | (`GET, [&quot;users&quot;, id]) =&gt; Services.Api.getUser(id)
  | _ =&gt; notFound;

let server = fun
  | (meth, [&quot;api&quot;, ...path]) =&gt; apiServer @@ (meth, path)
  | _ =&gt; notFound;</code></pre><p><i>Note</i> <code>@@</code> is a convenience operator for applying an argument (in this case the pair <code>(meth, path)</code>) to a function (in this case <code>apiServer</code>). We will use it to 'chain' together filters, servers, and services.</p><p>Here the main <code>server</code> is delegating all requests to <code>/api/...</code> endpoints to the <code>apiServer</code>, by passing it the request method and the <i>tail</i> of the path segment list, which is everything after <code>/api</code>. Again this is simple because of pattern-matching: we can split up the path segment list into a head and a tail, check that the head is <code>api</code>, and pass the tail forward.</p><p>This technique is especially useful with filters, which we will cover in a future chapter.</p><h2 id="setting-up-a-resource"><a href="#setting-up-a-resource" class="anchor"></a>Setting up a resource</h2><p>You can set up a <i>resource,</i> which is a normal server created with the <a href="../ReWeb/Server/index.html#val-resource"><code>ReWeb.Server.resource</code></a> function. A resource in ReWeb is the same as the one in <a href="https://guides.rubyonrails.org/getting_started.html#getting-up-and-running">Rails</a>, in other words--a set of routes that manage the CRUD operations of a collection of objects.</p><p>Resources involve several concepts--requests, responses, and usually also views and web forms with some JavaScript that can send the proper requests that web forms in browsers unfortunately can't. You will learn about all these concepts in the upcoming chapters, but for now here's a rough sketch of what a resource might look like:</p><pre><code class="ml">// Article.re

// Renders various pages that deal with the resource
module View = {
  let index = p =&gt; ...;
  let new_ = p =&gt; ...;
  let edit = (~id, p) =&gt; ...;
  let show = (~id, p) =&gt; ...;
};

// These are the services that handle the routes
let index = _ =&gt; View.index |&gt; Response.of_view |&gt; Lwt.return;
let create = _ =&gt; ...;
let new_ = _ =&gt; View.new_ |&gt; Response.of_view |&gt; Lwt.return;
let edit = (id, _) =&gt; View.edit(~id) |&gt; Response.of_view |&gt; Lwt.return;
let show = (id, _) =&gt; View.show(~id) |&gt; Response.of_view |&gt; Lwt.return;
let update = (meth, id, _) =&gt; ...;
let destroy = (id, _) =&gt; ...;

// This is the server that routes the requests to the correct services:
let resource = route =&gt; Server.resource(
  ~index,
  ~create,
  ~new_,
  ~edit,
  ~show,
  ~update,
  ~destroy,
  route,
);</code></pre><p>Recall from the previous section that you can set up a child server to handle the routes in a certain scope. So with this resource you can set it up to handle the <code>/articles/...</code> scope:</p><pre><code class="ml">let server = fun
  | (meth, [&quot;articles&quot;, ...path]) =&gt; Article.resource @@ (meth, path)
  | _ =&gt; notFound;</code></pre><p>The nice thing about the <code>Server.resource</code> function is that it sets up all the <code>GET</code> routes to be valid both with a trailing slash and without.</p></header></div></body></html>